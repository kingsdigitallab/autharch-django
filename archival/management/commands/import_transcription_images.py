import json
import os

from django.core import management
from django.core.files import File
from django.core.management.base import BaseCommand
from django.db import transaction

from ...models import ArchivalRecord, ArchivalRecordImage


HELP = 'Import transcription image files.'
IMAGES_PATH_HELP = 'Path to directory containing image files.'
MAP_PATH_HELP = 'Path to JSON map of RA References to record object IDs, ' \
    'as generated by export_ra_refs.'
REPLACE_HELP = 'Replace existing images (same page on same record only).'

EXISTING_IMAGE_ERROR = (
    'Cannot import image at "{}"; image already exists for page {} of record '
    '"{}"; use --replace to automatically overwrite such.')
MULTIPLE_PAGES_ERROR = 'Transcription image at "{}" has multiple valid pages.'
NO_ARCHIVAL_RECORD_ERROR = ('Transcription image at "{}" has no corresponding '
                            'ArchivalRecord object.')


class Command(BaseCommand):

    help = HELP

    def add_arguments(self, parser):
        parser.add_argument('-r', '--replace', help=REPLACE_HELP,
                            action='store_true')
        parser.add_argument('images_path', help=IMAGES_PATH_HELP,
                            metavar='DIR')
        parser.add_argument('map_path', help=MAP_PATH_HELP, metavar='MAP')

    @transaction.atomic
    def handle(self, *args, **options):
        replace = options['replace']
        with open(options['map_path']) as fp:
            self.refs_map = json.load(fp)
        imported_images = 0
        for dirpath, dirnames, filenames in os.walk(options['images_path']):
            for filename in filenames:
                if os.path.splitext(filename)[1] == '.jpg':
                    image_path = os.path.join(dirpath, filename)
                    if self._import_transcription(image_path, replace):
                        self.stdout.write(image_path)
                        imported_images += 1
        self.stdout.write('Imported {} images.'.format(imported_images))
        management.call_command('createinitialrevisions')

    def _get_record(self, filename):
        """Return the ArchivalRecord that the transcription image called
        `filename` belongs to, and the transcription's page number."""
        page = os.path.splitext(filename)[0]
        parts = page.split('_')
        identifier = '/'.join([part for part in parts[:-1] if part])
        try:
            record_id = self.refs_map['refs'][identifier]
            record = ArchivalRecord.objects.get(pk=record_id)
        except KeyError:
            record = None
        except ArchivalRecord.DoesNotExist:
            record = None
        return record, page

    def _import_transcription(self, image_path, replace):
        filename = os.path.basename(image_path)
        record, page = self._get_record(filename)
        if record is None:
            self.stderr.write(NO_ARCHIVAL_RECORD_ERROR.format(filename))
            return False
        try:
            existing_image = ArchivalRecordImage.objects.get(record=record,
                                                             order=page)
        except ArchivalRecordImage.DoesNotExist:
            existing_image = None
        if existing_image is not None:
            if replace:
                existing_image.delete()
            else:
                self.stderr.write('Duplicate: {} = {}'.format(
                    os.path.basename(image_path),
                    os.path.basename(existing_image.image.path))
                )
                return False
        image = ArchivalRecordImage(record=record, order=page)
        with open(image_path, 'rb') as fh:
            image_file = File(fh)
            image.image.save(filename, image_file, save=False)
        image.save()
        return True
